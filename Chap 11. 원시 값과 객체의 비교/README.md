[[Core JavaScript] #1 변수 선언과 데이터 할당 시 메모리 영역의 변화](https://novlog.tistory.com/entry/Core-JavaScript-1-변수-선언과-데이터-할당-시-메모리-영역의-변화)

- 원시 타입의 값 : ( = 변경 불가능한 값 )
    - 원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장된다.
    - 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 **원시 값이 복사되어 전달된다**. 이를 값에 의한 전달이라고 한다.
- 객체 타입의 값 : ( = 변경 가능한 값 )
    - 객체를 변수에 할당하면 변수(확보된 메모리 공간)에는 참조 값이 저장된다.
    - 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 **참조 값이 복사되어 전달된다.** 이를 참조에 의한 전달이라 한다.

## 11.1 원시 값

### 11.1.1 변경 불가능한 값

- 읽기전용으로서 값을 변경할 수 없다.
- 변경 불가능하다는 것은 변수가 아니라 값에 대한 진술이다.
- 상수는 변경 불가능한 값이 아니다. 재할당이 금지된 변수일 뿐이다.
- const 키워드를 사용해 선언한 변수에 할당한 원시 값(상수)은 변경할 수 없다.
- 하지만 const 키워드를 사용해 선언한 변수에 할당한 객체는 변경할 수 있다.

- 변수 값을 재할당하게 되면 변수가 참조하던 메모리 공간의 주소가 바뀐다. ⇒ 불변성
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/dbc827b4-3bc5-407e-aa2d-3c5b00d98511/Untitled.png)
    
    - 변수가 참조하던 메모리 공간의 주소가 변경된 이유는 변수에 할당된 원시 값이 변경 불가능한 값이기 때문이다.
    - 만약 원시 값이 변경 가능했더라면 새로운 원시 값을 재할당 했을 때 원시 값 자체를 변경하면 그만이다.
    - 그럼 변수가 처음 참조했던 메모리 공간의 주소는 영영 바뀌지 않는다.
    - 불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.

### 11.1.2 문자열과 불변성

- 문자열은 몇개의 문자로 이뤄졌느냐에 따라 필요한 메모리 공간의 크기가 결정된다. ( 1개의 문자는 2바이트의 메모리 공간에 저장 )
- 자바스크립트에서는 개발자의 편의를 위해 원시 타입인 문자열 타입을 제공한다.
- 자바스크립트의 문자열은 원시 타입이며, 변경 불가능하다.
- 문자열은 유사 배열 객체이면서 이터러블이므로 배열과 유사하게 각 문자에 접근할 수 있다.

? 원시 값인 문자열이 객체일 수 있다 str.length  → 원시 값을 객체처럼 사용하면 원시 값을 감싸는 래퍼 객체로 자동 변환된다.

```jsx
var str = 'string';

str[0] = 'S';

console.log(str); // string 
```

- 문자열은 변경 불가능한 값이기 때문에 이미 생성된 문자열의 일부 문자를 변경해도 반영되지 않는다.

### 11.1.3 값에 의한 전달

> 변수에 변수를 할당했을 때 무엇이 어떻게 전달되는가?
> 

```jsx
var score = 80;
var copy = score;

console.log(score); // 80
console.log(copy); // 80

score = 100;

console.log(score); // 100
console.log(copy); // ? : answer = 80
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ed0227d6-2cf5-4560-b783-8c65be3e2999/Untitled.png)

- 변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수에는 할당 되는 **변수의 원시값이 복사되어 전달된다.**
- 그러나 score 변수와 copy 변수의 값 80은 **다른 메모리 공간에 저장된 별개의 값이다.**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a52035a7-2895-48b8-b1aa-96f7a5084652/Untitled.png)

- 변수에 원시 값을 갖는 변수를 할당하는 시점에는 두 변수가 같은 원시 값을 참조하다가 어느 한쪽의 변수에 재할당이 이뤄졌을 때 비로소 새로운 메모리 공간에 재할당된 값을 저장하도록 동작할 수도 있다. (파이썬)

**값에 의한 전달** 

- “값에 의한 전달” 은 자바스크립트에서 오해의 소지가 있는데, 엄격하게 표현하면 변수에는 값이 저장되는 것이 아니라 메모리 주소가 저장되기 때문이다.  변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하고 있다.
- 식별자로 값을 구별해서 식별한다는 것은 식별자가 기억하고 있는 메모리 주소를 통해 메모리 공간에 저장된 값에 접근할 수 있다는 것을 의미한다.
- 값에 의한 전달도 사실은 값을 전달하는 것이 아니라 메모리 주소를 전달한다. 단, 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다.
- 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다.

## 11.2 객체

- 객체는 원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다.
- 객체를 관리하는 방식이 복잡해서 브라우저 제조사마다 구현방식이 다를 수 있다.

<aside>
💡 **자바스크립트 객체의 관리 방식**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/dc366b67-6d73-47e0-a7a2-305ffc4b180f/Untitled.png)

자바스크립트 객체는 프로퍼티 키를 인덱스로 사용하는 **해시 테이블**이라고 생각할 수 있다. 대부분의 자바스크립트 엔진은 해시 테이블과 유사하지만 높은 성능을 위해 일반적인 해시 테이블보다 나은 방법으로 객체를 구현한다. 프로퍼티에 효율적으로 접근하기 위해 동적 탐색 대신 **히든 클래스** 라는 방식을 사용해 객체의 프로퍼티에 접근하는 정도의 성능을 보장한다.

</aside>

### 11.2.1 변경 가능한 값

- 객체(참조) 타입의 값, 즉 객체는 변경 가능한 값이다.
- 원시 값을 할당한 변수는 원시 값 자체를 값으로 갖는다.
- 객체를 할당한 변수가 기억하는 메모리주소를 통해 메모리 공간에 접근하면 참조 값에 접근할 수 있다.
- 참조 값은 생성된 객체가 저장된 메모리 공간의 주소, 그 자체이다.
- 객체는 변경 가능한 값이므로 객체를 할당한 변수는 재할당 없이 객체 메모리에 저장된 객체를 직접 변경할 수 있다.
- 객체를 복사해 생성하는 비용을 절약하여 성능을 향상시키기 위해 객체는 변경 가능한 값으로 설계되어 있다.
- 원시 값과는 다르게 **여러 개의 식별자가 하나의 객체를 공유할 수 있다.**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b6ea853e-8948-4bc2-ad57-a74510f3abd5/Untitled.png)

<aside>
💡 **얕은 복사와 깊은 복사** 

얕은 복사는 한 단계까지만 복사, 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사.

```jsx
const o = { x: {y: 1} };

// 얕은 복사
const c1 = { ...o };
console.log( c1 === o ); // false
consoel.log( c1.x === o.x); // true

// lodash의 cloneDeep을 사용한 깊은 복사
// npm install lodash 로 설치한후 node.js 환경에서 실행
const _ = require('lodash');

// 깊은 복사
const c2 = _.cloneDeep(o);
console.log(c2 === o); // false
console.log(c2.x === o.x); // false
```

얕은 복사와 깊은 복사로 생성된 객체는 **원본과는 다른 객체다.** 즉, 원본과 복사본은 참조 값이 다른 별개의 객체이다. 하지만 **⭐️얕은 복사는 객체에 중첩되어 있는 객체의 경우 참조 값을 복사⭐️하고 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사해서 원시 값처럼 완전한 복사본**을 만든다는 차이가 있다. 

```jsx
const v = 1;

// "깊은 복사" 라고 부르기도 한다.
const c1 = v;
console.log(c1 === v); // true

const o = { x: 1 },

// "얕은 복사" 라고 부르기도 한다.
const c2 = o;
console.log(c2 === o);
```

참고로 다음과 같이 원시 값을 할당한 변수를 다른 변수에 할당하는 것을 깊은 복사, 객체를 할당한 변수를 다른 변수에 할당하는 것을 얕은 복사라고 부르는 경우도 있다.

</aside>

### 11.2.2 참조에 의한 전달

- 여러개의 식별자가 하나의 객체를 공유할 수 있다.

```jsx
var person = {
	name: 'lee',
};

// 참조 값을 얕은 복사
var copy = person;
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d962e3f5-091a-4982-8d39-d1f4d75e5b71/Untitled.png)

- 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달이라 한다.
- 원본 person 과 참조 copy는 저장된 메모리 주소는 다르지만 동일한 참조 값을 갖는다. 다시 말해, 모두 동일한 객체를 가리킨다.
- 두개의 식별자가 하나의 객체를 공유한다!
- 값에 의한 전달과 참조에 의한 전달은 **식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사**해서 그 주소를 전달한다는 면에서는 동일하다.
    - **다만, 식별자가 기억하는 메모리 공간, 즉 변수에 저장되어 있는 값이 원시 값이냐 참조 값이냐의 차이만 있을 뿐**이다.
    - 따라서 자바스크립트에는 “참조에 의한 전달”은 존재하지 않고 “값에 의한 전달”만이 존재한다고 말할 수 있다.

**📚퀴즈**

```jsx
var person1 = {
	name: 'lee'
};

var person2 = {
	name: 'lee'
};

console.log(person1 === person2); // false 객체 리터럴은 평가될 때 마다 새로운 객체를 생성한다 -> 다른 메모리에 저장된 별개의 객체이다.
console.log(person1.name === person2.name); // true 값으로 평가될 수 있는 표현식 'lee' === 'lee' 이다! 
```
